package shetj.me.base.qmui

import android.content.Intent
import android.os.Bundle
import android.widget.FrameLayout
import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentManager
import com.qmuiteam.qmui.util.QMUIStatusBarHelper
import com.qmuiteam.qmui.widget.QMUIWindowInsetLayout
import com.trello.rxlifecycle3.components.support.RxAppCompatActivity
import timber.log.Timber
import java.lang.reflect.Field

/**
 * the container activity for [QMUIFragment].
 * Created by cgspine on 15/9/14.
 */
abstract class QMUIFragmentActivity : RxAppCompatActivity() {
    private var mFragmentContainer: QMUIWindowInsetLayout? = null

    protected abstract val contextViewId: Int

    val fragmentContainer: FrameLayout?
        get() = mFragmentContainer

    /**
     * get the current Fragment.
     */
    val currentFragment: QMUIFragment?
        get() = supportFragmentManager.findFragmentById(contextViewId) as QMUIFragment?

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        QMUIStatusBarHelper.translucent(this)
        mFragmentContainer = QMUIWindowInsetLayout(this)
        mFragmentContainer!!.id = contextViewId
        setContentView(mFragmentContainer)
    }

    override fun onBackPressed() {
        val fragment = currentFragment
        fragment?.popBackStack()
    }

    /**
     * start a new fragment and then destroy current fragment.
     * assume there is a fragment stack(A->B->C), and you use this method to start a new
     * fragment D and destroy fragment C. Now you are in fragment D, if you want call
     * [.popBackStack] to back to B, what the animation should be? Sometimes we hope run
     * animation generated by transition B->C, but sometimes we hope run animation generated by
     * transition C->D. this why second parameter exists.
     *
     * @param fragment                      new fragment to start
     * @param useNewTransitionConfigWhenPop if true, use animation generated by transition C->D,
     * else, use animation generated by transition B->C
     */
    fun startFragmentAndDestroyCurrent(fragment: QMUIFragment, useNewTransitionConfigWhenPop: Boolean): Int {
        val transitionConfig = fragment.onFetchTransitionConfig()
        val tagName = fragment.javaClass.simpleName
        val fragmentManager = supportFragmentManager
        val transaction = supportFragmentManager.beginTransaction()
                .setCustomAnimations(transitionConfig.enter, transitionConfig.exit,
                        transitionConfig.popenter, transitionConfig.popout)
                .replace(contextViewId, fragment, tagName)
        val index = transaction.commit()
        Utils.findAndModifyOpInBackStackRecord(fragmentManager, -1, object : Utils.OpHandler {
            override fun handle(op: Any): Boolean {
                val cmdField: Field?
                try {
                    cmdField = op.javaClass.getDeclaredField("cmd")
                    cmdField.isAccessible = true
                    val cmd = cmdField.get(op) as Int
                    if (cmd == 1) {
                        if (useNewTransitionConfigWhenPop) {
                            val popEnterAnimField = op.javaClass.getDeclaredField("popEnterAnim")
                            popEnterAnimField.isAccessible = true
                            popEnterAnimField.set(op, transitionConfig.popenter)

                            val popExitAnimField = op.javaClass.getDeclaredField("popExitAnim")
                            popExitAnimField.isAccessible = true
                            popExitAnimField.set(op, transitionConfig.popout)
                        }

                        val oldFragmentField = op.javaClass.getDeclaredField("fragment")
                        oldFragmentField.isAccessible = true
                        val fragmentObj = oldFragmentField.get(op)
                        oldFragmentField.set(op, fragment)
                        val backStackNestField = Fragment::class.java.getDeclaredField("mBackStackNesting")
                        backStackNestField.isAccessible = true
                        var oldFragmentBackStackNest = backStackNestField.get(fragmentObj) as Int
                        backStackNestField.set(fragment, oldFragmentBackStackNest)
                        backStackNestField.set(fragmentObj, --oldFragmentBackStackNest)
                        return true
                    }
                } catch (e: NoSuchFieldException) {
                    e.printStackTrace()
                } catch (e: IllegalAccessException) {
                    e.printStackTrace()
                }

                return false
            }
        })
        return index
    }

    fun startFragment(fragment: QMUIFragment): Int {
        Timber.i("startFragment")
        val transitionConfig = fragment.onFetchTransitionConfig()
        val tagName = fragment.javaClass.simpleName
        return supportFragmentManager
                .beginTransaction()
                .setCustomAnimations(transitionConfig.enter, transitionConfig.exit, transitionConfig.popenter, transitionConfig.popout)
                .replace(contextViewId, fragment, tagName)
                .addToBackStack(tagName)
                .commit()
    }

    /**
     * Exit the current Fragmentã€‚
     */
    fun popBackStack() {
        Timber.i("popBackStack: getSupportFragmentManager().getBackStackEntryCount() = %s", supportFragmentManager.backStackEntryCount)
        if (supportFragmentManager.backStackEntryCount <= 1) {
            val fragment = currentFragment
            if (fragment == null) {
                finish()
                return
            }
            val transitionConfig = fragment.onFetchTransitionConfig()
            val toExec = fragment.onLastFragmentFinish()
            if (toExec != null) {
                if (toExec is QMUIFragment) {
                    startFragment(toExec)
                } else if (toExec is Intent) {
                    finish()
                    startActivity(toExec)
                    overridePendingTransition(transitionConfig.popenter, transitionConfig.popout)
                } else {
                    throw Error("can not handle the result in onLastFragmentFinish")
                }
            } else {
                finish()
                overridePendingTransition(transitionConfig.popenter, transitionConfig.popout)
            }
        } else {
            supportFragmentManager.popBackStackImmediate()
        }
    }

    /**
     * pop back to a clazz type fragment
     *
     *
     * Assuming there is a back stack: Home -> List -> Detail. Perform popBackStack(Home.class),
     * Home is the current fragment
     *
     *
     * if the clazz type fragment doest not exist in back stack, this method is Equivalent
     * to popBackStack()
     *
     * @param clazz the type of fragment
     */
    fun popBackStack(clazz: Class<out QMUIFragment>) {
        supportFragmentManager.popBackStack(clazz.simpleName, 0)
    }

    /**
     * pop back to a non-clazz type Fragment
     *
     * @param clazz the type of fragment
     */
    fun popBackStackInclusive(clazz: Class<out QMUIFragment>) {
        supportFragmentManager.popBackStack(clazz.simpleName, FragmentManager.POP_BACK_STACK_INCLUSIVE)
    }

    companion object {
        private val TAG = "QMUIFragmentActivity"
    }
}